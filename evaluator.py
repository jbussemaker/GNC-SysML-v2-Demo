"""
A script that evaluates a given GNC architecture instance, as generated by ADORE from the gncDesignSpace in gnc.sysml.
Execute the script to evaluate the `annotated_example_architecture_unevaluated.sysml` model.

The script uses Syside Automator: refer to https://docs.sensmetry.com/automator/index.html for how to set it up.

Copyright (c) 2026, Jasper Bussemaker, DLR e.V. All rights reserved.
"""
import syside
import syside.gc
import pathlib
import logging
import itertools
import numpy as np
import logging.config
from typing import List

log = logging.getLogger('gnc')

model_dir = pathlib.Path(__file__).parent.absolute() / 'model'
lib_dir = model_dir / 'library'



def evaluate_architecture(architecture_model_path, output_model_path=None):
    # Load the model
    model = _load_model(architecture_model_path)

    kg_units = _get_kg_units_attr(model)

    with model.documents[-1].lock() as doc:
        root = doc.root_node

        # Get the architecture part we are evaluating
        arch_part = _get_architecture_part(root)
        log.info(f'Evaluating: {arch_part.name}')

        # Calculate mass and failure rate
        _calculate_mass(model, arch_part, kg_units)
        _calculate_failure_rate(arch_part)

        # Write resulting model
        if output_model_path is None:
            output_model_path = str(architecture_model_path[:-6])+'_evaluated.sysml'
        with open(output_model_path, 'wb') as fp:
            fp.write(syside.pprint(root).encode('utf-8'))


def _calculate_mass(model: syside.Model, part: syside.PartUsage, kg_units: syside.AttributeUsage) -> float:
    """
    Evaluate the mass of the architecture.
    This is done by simply summing the masses of all the elements: sensors, computers, actuators.

    Currently, Syside Automator does not support the evaluation of the expressions defined in the SysML model,
    so we have to do the calculations here in Python.
    """

    # Find the mass attribute
    for feature in part.owned_features:
        if isinstance(feature, syside.AttributeUsage) and feature.name == 'mass':
            mass_attr = feature
            break
    else:
        return 0.

    # # Evaluate the mass attribute
    # # Based on the example: https://docs.sensmetry.com/examples/unit_evaluation.html#evaluating-with-unit-conversion
    # compiler = syside.Compiler()
    # evaluated_value, report = compiler.evaluate_feature(
    #     feature=mass_attr,
    #     scope=part,
    #     stdlib=model.environment.lib,
    #     experimental_quantities=True,
    # )
    #
    # if report.fatal:
    #     diagnostics = '\n'.join([str(diag) for diag in report.diagnostics])
    #     raise ValueError(f'Could not evaluate mass:\n{diagnostics}')
    #
    # return evaluated_value

    # Check if the mass attribute has a value
    if mass_attr.feature_value is not None:
        value = mass_attr.feature_value.value
        if (isinstance(value, syside.OperatorExpression) and len(value.children) == 2 and
                value.operator == syside.Operator.Quantity):

            # Return the literal value of the first argument to the quantity operator
            mass = float(value.children.elements[0].feature_value.value.value)
            log.info(f'Mass of {part.qualified_name!s} = {mass} kg')
            return mass

    # Otherwise, get the masses of the contained parts
    mass = 0.
    for sub_part in part.children.elements:
        if isinstance(sub_part, syside.PartUsage):

            # Skip if the part is deselected
            if sub_part.multiplicity is not None:
                upper_bound = sub_part.multiplicity.upper_bound
                if upper_bound is not None and upper_bound.value == 0:
                    continue

            # Skip if the sub-part refers to multiple instances:
            #   part sensors = (sensors_1, sensors_2, ...);
            if sub_part.feature_value is not None:
                value = sub_part.feature_value.value
                if isinstance(value, syside.OperatorExpression) and value.operator == syside.Operator.Comma:
                    continue

            # Calculate the mass of the sub part
            mass += _calculate_mass(model, sub_part, kg_units)

    # Write the total mass
    log.info(f'Aggregate mass of {part.qualified_name!s} = {mass} kg')

    # Create a quantity operator
    quantity_expression: syside.OperatorExpression
    _, quantity_expression = mass_attr.feature_value_member.set_member_element(syside.OperatorExpression)
    quantity_expression.operator = syside.ExplicitOperator.Quantity

    # Add the first parameter: a rational literal
    _, value_feature = quantity_expression.children.append(syside.ParameterMembership, syside.Feature)
    _, literal_value = value_feature.feature_value_member.set_member_element(syside.LiteralRational)
    literal_value.value = mass

    # Add the second parameter: a reference to the kg attribute
    _, units_feature = quantity_expression.children.append(syside.ParameterMembership, syside.Feature)
    _, reference_expression = units_feature.feature_value_member.set_member_element(syside.FeatureReferenceExpression)
    reference_expression.referent_member.set_member_element(kg_units)

    return mass


def _calculate_failure_rate(arch_part: syside.PartUsage):
    """
    Evaluate the failure rate of the architecture. This is done by getting the failure rates of the objects and the
    connection between the objects, and then calculating the probability that no single connected path (from a sensor to
    an actuator) remains.

    This is done using code from SBArchOpt:
    https://github.com/jbussemaker/SBArchOpt/blob/43b099196a0fc4529949f02a6530f146b95a6ec3/sb_arch_opt/problems/gnc.py#L473
    """

    # Get object failure rates
    failure_rates = [
        np.array(_get_failure_rates(arch_part, 'sensors')),
        np.array(_get_failure_rates(arch_part, 'computers')),
        np.array(_get_failure_rates(arch_part, 'actuators')),
    ]

    # Get object connections
    obj_conns = [
        _get_connections(arch_part, 'dataConnection'),  # Sensors to computers
        _get_connections(arch_part, 'actuatorSignalConnection'),  # Computers to actuators
    ]


    # Calculate the failure rate
    failure_rate = _calc_failure_rate(failure_rates, obj_conns)
    log_failure_rate = float(np.log10(failure_rate))
    log.info(f'System-level failure rate = {failure_rate} (log = {log_failure_rate})')

    from sb_arch_opt.problems.gnc import GNCProblemBase
    fr_ = GNCProblemBase.calc_failure_rate(failure_rates, obj_conns)
    assert log_failure_rate == fr_

    # Write the failure rate
    for fr_attr in arch_part.owned_features:
        if isinstance(fr_attr, syside.AttributeUsage) and fr_attr.name == 'failureRate':

            _, value = fr_attr.feature_value_member.set_member_element(syside.LiteralRational)
            value.value = failure_rate

        elif isinstance(fr_attr, syside.AttributeUsage) and fr_attr.name == 'logFailureRate':

            assert log_failure_rate < 0.
            _, expression = fr_attr.feature_value_member.set_member_element(syside.OperatorExpression)
            expression.operator = syside.ExplicitOperator.Minus

            _, feature = expression.children.append(syside.ParameterMembership, syside.Feature)
            _, value = feature.feature_value_member.set_member_element(syside.LiteralRational)
            value.value = -log_failure_rate


def _get_failure_rates(arch_part: syside.PartUsage, name: str) -> List[float]:
    failure_rates = []

    # Find the subsystem instances that we are interested in
    for part in arch_part.children.elements:
        if isinstance(part, syside.PartUsage) and part.name.startswith(name):

            # Skip if the part refers to multiple instances:
            #   part sensors = (sensors_1, sensors_2, ...);
            if part.feature_value is not None:
                value = part.feature_value.value
                if isinstance(value, syside.OperatorExpression) and value.operator == syside.Operator.Comma:
                    continue

            # Get the failure rate
            failure_rate = None
            for sub_part in part.children.elements:
                if isinstance(sub_part, syside.PartUsage):

                    # Skip if the part is deselected
                    if sub_part.multiplicity is not None:
                        upper_bound = sub_part.multiplicity.upper_bound
                        if upper_bound is not None and upper_bound.value == 0:
                            continue

                    # Get the failure rate
                    for fr_attr in sub_part.owned_features:
                        if isinstance(fr_attr, syside.AttributeUsage) and fr_attr.name == 'failureRate':
                            failure_rate = float(fr_attr.feature_value.value.value)
                            log.info(f'Failure rate of {part.name} = {failure_rate}')

                            failure_rates.append(failure_rate)
                            break
                    break

            # Write the failure rate to the subsystem-level attribute
            assert failure_rate is not None
            for fr_attr in part.owned_features:
                if isinstance(fr_attr, syside.AttributeUsage) and fr_attr.name == 'failureRate':

                    _, value = fr_attr.feature_value_member.set_member_element(syside.LiteralRational)
                    value.value = failure_rate
                    break

    return failure_rates


def _get_connections(arch_part: syside.PartUsage, name: str):

    def get_conn_idx(connector: syside.Feature):
        # Get the feature chain of the connector: e.g. sensors_1.sensorA.dataOutPort.data
        referenced_element = connector.referenced_feature
        feature_chain = list(referenced_element.chaining_features)

        # Get the top-level element (the subsystem)
        subsystem_el = feature_chain[0]

        # Check if the name ends with _<int>
        if '_' in subsystem_el.name:
            _, nr = subsystem_el.name.split('_')
            return int(nr)-1

        # Otherwise there is only one instance of that element
        return 0

    # Find the connections we are interested in
    connections = []
    for connection in arch_part.children.elements:
        if isinstance(connection, syside.ConnectionUsage) and connection.name.startswith(name):

            # Skip if the connection refers to multiple instances:
            #   connection conn = (conn_1, conn_2, ...);
            if connection.feature_value is not None:
                value = connection.feature_value.value
                if isinstance(value, syside.OperatorExpression) and value.operator == syside.Operator.Comma:
                    continue

            # Get the connection ends
            source, target = connection.declared_ends.elements
            source_idx, target_idx = get_conn_idx(source), get_conn_idx(target)
            log.info(f'{name} from {source_idx} to {target_idx}')
            connections.append((source_idx, target_idx))

    return connections


def _get_kg_units_attr(model: syside.Model) -> syside.AttributeUsage:
    for node in model.nodes(syside.AttributeUsage, considered_document_kinds=syside.DocumentKind.ENVIRONMENT):
        if node.short_name == 'kg' and node.owner.name == 'SI':
            return node
    raise RuntimeError('kg units not found!')


def _load_model(architecture_model_path) -> syside.Model:

    # Set up the environment to also include the library files
    lib_files = syside._loading.get_stdlib_files()
    for library_file in lib_dir.glob('*.sysml'):
        lib_files.append(library_file)
    env = syside.Environment.from_stdlib_files(lib_files)

    # Get the design space model path
    design_space_model_path = model_dir / 'gnc.sysml'

    # Load the design space model and the architecture model
    log.info(f'Loading: {architecture_model_path}')
    model, _ = syside.load_model([design_space_model_path, architecture_model_path],
                                 environment=env, warnings_as_errors=True)

    return model


def _get_architecture_part(root: syside.Namespace) -> syside.PartUsage:
    # Get the package
    package: syside.Package
    for element in root.children.elements:
        if isinstance(element, syside.Package):
            package = element
            break
    else:
        raise RuntimeError('Package not found!')

    # Get the architecture part
    prefix: syside.MetadataUsage
    for element in package.children.elements:
        if isinstance(element, syside.PartUsage):
            for prefix in element.prefixes.elements:
                if prefix.metadata_definition.name == 'architecture':
                    return element
    raise RuntimeError('Architecture part not found!')


def _calc_failure_rate(failure_rates, obj_conns):
    """
    `failure_rates` is a list of failure rates for the objects.
    `obj_conns` is a list of tuples with edge indices (source, target).

    Code from SBArchOpt:
    https://github.com/jbussemaker/SBArchOpt/blob/43b099196a0fc4529949f02a6530f146b95a6ec3/sb_arch_opt/problems/gnc.py#L473
    """

    # Create connection matrices for each connection (sensors-computers and computers-actuators)
    conn_matrices = []
    for i, edges in enumerate(obj_conns):
        matrix = np.zeros((len(failure_rates[i]), len(failure_rates[i+1])), dtype=int)
        for i_src, i_tgt in edges:
            matrix[i_src, i_tgt] = 1
        conn_matrices.append(matrix)

    # Loop over combinations of failed components
    def _branch_failures(i_rates=0, src_connected_mask=None) -> float:
        calc_downstream = i_rates < len(conn_matrices)-1
        rates, tgt_rates = failure_rates[i_rates], failure_rates[i_rates+1]
        conn_mat = conn_matrices[i_rates]

        # Loop over failure scenarios: the cartesian product of [ok, failed] for each object
        if src_connected_mask is None:
            src_connected_mask = np.ones((len(rates),), dtype=bool)
        total_rate = 0.
        for ok_sources in itertools.product(*[([False, True] if src_connected_mask[i_conn] else [False])
                                              for i_conn in range(len(rates))]):
            if i_rates > 0 and not any(ok_sources):
                continue

            # Calculate probability of this scenario occurring
            ok_sources = list(ok_sources)
            occurrence_prob = rates.copy()
            occurrence_prob[ok_sources] = 1-occurrence_prob[ok_sources]
            prob = 1.
            for partial_prob in occurrence_prob[src_connected_mask]:
                prob *= partial_prob
            occurrence_prob = prob

            # Check which targets are still connected in this scenario
            conn_mat_ok = conn_mat[ok_sources, :].T
            connected_targets = np.zeros((conn_mat_ok.shape[0],), dtype=bool)
            for i_conn_tgt in range(conn_mat_ok.shape[0]):
                connected_targets[i_conn_tgt] = np.any(conn_mat_ok[i_conn_tgt])

            # If no connected targets are available the system fails
            tgt_failure_rates = tgt_rates[connected_targets]
            if len(tgt_failure_rates) == 0:
                total_rate += occurrence_prob
                continue

            # Calculate the probability that the system fails because all remaining connected targets fail
            all_tgt_fail_prob = 1.
            for prob in tgt_failure_rates:
                all_tgt_fail_prob *= prob
            total_rate += occurrence_prob*all_tgt_fail_prob

            # Calculate the probability that the system fails because remaining downstream connected targets fail
            if calc_downstream:
                total_rate += occurrence_prob*_branch_failures(
                    i_rates=i_rates+1, src_connected_mask=connected_targets)

        return total_rate

    failure_rate = _branch_failures()
    return failure_rate


def capture_log(level='INFO'):
    logging.config.dictConfig({
        'version': 1, 'disable_existing_loggers': False,
        'formatters': { 'console': { 'format': '%(levelname)- 8s %(asctime)s %(name)- 18s: %(message)s' } },
        'handlers': { 'console': { 'level': level, 'class': 'logging.StreamHandler', 'formatter': 'console' } },
        'loggers': { 'gnc': { 'handlers': ['console'], 'level': level } },
    })


if __name__ == '__main__':
    capture_log()
    evaluate_architecture('results/annotated_example_architecture_unevaluated.sysml')
